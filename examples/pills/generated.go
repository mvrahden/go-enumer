// Code generated by "go-enumer (github.com/mvrahden/go-enumer)"; DO NOT EDIT.

package pills

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"gopkg.in/yaml.v3"
	"io"
	"strconv"
)

var (
	ErrNoValidEnum = errors.New("not a valid enum")
)

const (
	_PillAliasedString      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillAliasedLowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillAliasedValues  = [5]PillAliased{0, 1, 2, 3, 4}
	_PillAliasedStrings = [5]string{_PillAliasedString[0:7], _PillAliasedString[7:14], _PillAliasedString[14:23], _PillAliasedString[23:34], _PillAliasedString[47:56]}
)

// _PillAliasedNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillAliased.
func _PillAliasedNoOp() {
	var x [1]struct{}
	_ = x[PillAliasedPlacebo-(0)]
	_ = x[PillAliasedAspirin-(1)]
	_ = x[PillAliasedIbuprofen-(2)]
	_ = x[PillAliasedParacetamol-(3)]
	_ = x[PillAliasedAcetaminophen-(3)]
	_ = x[PillAliasedVitaminC-(4)]
}

// PillAliasedValues returns all values of the enum.
func PillAliasedValues() []PillAliased {
	cp := _PillAliasedValues
	return cp[:]
}

// PillAliasedStrings returns a slice of all String values of the enum.
func PillAliasedStrings() []string {
	cp := _PillAliasedStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillAliased) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillAliased) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillAliased(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillAliased(%d) instead.
func (_p PillAliased) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillAliased(%d)", _p)
	}
	idx := uint(_p)
	return _PillAliasedStrings[idx]
}

var (
	_PillAliasedStringToValueMap = map[string]PillAliased{
		_PillAliasedString[0:7]:   PillAliasedPlacebo,
		_PillAliasedString[7:14]:  PillAliasedAspirin,
		_PillAliasedString[14:23]: PillAliasedIbuprofen,
		_PillAliasedString[23:34]: PillAliasedParacetamol,
		_PillAliasedString[34:47]: PillAliasedAcetaminophen,
		_PillAliasedString[47:56]: PillAliasedVitaminC,
	}
	_PillAliasedLowerStringToValueMap = map[string]PillAliased{
		_PillAliasedLowerString[0:7]:   PillAliasedPlacebo,
		_PillAliasedLowerString[7:14]:  PillAliasedAspirin,
		_PillAliasedLowerString[14:23]: PillAliasedIbuprofen,
		_PillAliasedLowerString[23:34]: PillAliasedParacetamol,
		_PillAliasedLowerString[34:47]: PillAliasedAcetaminophen,
		_PillAliasedLowerString[47:56]: PillAliasedVitaminC,
	}
)

// PillAliasedFromString determines the enum value with an exact case match.
func PillAliasedFromString(raw string) (PillAliased, bool) {
	v, ok := _PillAliasedStringToValueMap[raw]
	if !ok {
		return PillAliased(0), false
	}
	return v, true
}

// PillAliasedFromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillAliasedFromStringIgnoreCase(raw string) (PillAliased, bool) {
	v, ok := PillAliasedFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillAliasedLowerStringToValueMap[raw]
	if !ok {
		return PillAliased(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillAliased.
func (_p PillAliased) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillAliased. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillAliased.
func (_p *PillAliased) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillAliased.
func (_p PillAliased) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillAliased.
func (_p *PillAliased) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillAliased: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillAliased.
func (_p PillAliased) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillAliased. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillAliased.
func (_p *PillAliased) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillAliased should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillAliased.
func (_p PillAliased) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillAliased. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillAliased.
func (_p *PillAliased) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillAliased: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillAliased.
func (_p PillAliased) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillAliased. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillAliased.
func (_p *PillAliased) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillAliased.
func (_p PillAliased) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillAliased. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillAliased.
func (_p *PillAliased) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillAliased must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillAliased cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillAliasedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillAliased", str)
	}
	return nil
}

const (
	_PillUnsignedString      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillUnsignedLowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillUnsignedValues  = [5]PillUnsigned{0, 1, 2, 3, 4}
	_PillUnsignedStrings = [5]string{_PillUnsignedString[0:7], _PillUnsignedString[7:14], _PillUnsignedString[14:23], _PillUnsignedString[23:34], _PillUnsignedString[47:56]}
)

// _PillUnsignedNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillUnsigned.
func _PillUnsignedNoOp() {
	var x [1]struct{}
	_ = x[PillUnsignedPlacebo-(0)]
	_ = x[PillUnsignedAspirin-(1)]
	_ = x[PillUnsignedIbuprofen-(2)]
	_ = x[PillUnsignedParacetamol-(3)]
	_ = x[PillUnsignedAcetaminophen-(3)]
	_ = x[PillUnsignedVitaminC-(4)]
}

// PillUnsignedValues returns all values of the enum.
func PillUnsignedValues() []PillUnsigned {
	cp := _PillUnsignedValues
	return cp[:]
}

// PillUnsignedStrings returns a slice of all String values of the enum.
func PillUnsignedStrings() []string {
	cp := _PillUnsignedStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillUnsigned) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillUnsigned) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillUnsigned(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillUnsigned(%d) instead.
func (_p PillUnsigned) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillUnsigned(%d)", _p)
	}
	idx := uint(_p)
	return _PillUnsignedStrings[idx]
}

var (
	_PillUnsignedStringToValueMap = map[string]PillUnsigned{
		_PillUnsignedString[0:7]:   PillUnsignedPlacebo,
		_PillUnsignedString[7:14]:  PillUnsignedAspirin,
		_PillUnsignedString[14:23]: PillUnsignedIbuprofen,
		_PillUnsignedString[23:34]: PillUnsignedParacetamol,
		_PillUnsignedString[34:47]: PillUnsignedAcetaminophen,
		_PillUnsignedString[47:56]: PillUnsignedVitaminC,
	}
	_PillUnsignedLowerStringToValueMap = map[string]PillUnsigned{
		_PillUnsignedLowerString[0:7]:   PillUnsignedPlacebo,
		_PillUnsignedLowerString[7:14]:  PillUnsignedAspirin,
		_PillUnsignedLowerString[14:23]: PillUnsignedIbuprofen,
		_PillUnsignedLowerString[23:34]: PillUnsignedParacetamol,
		_PillUnsignedLowerString[34:47]: PillUnsignedAcetaminophen,
		_PillUnsignedLowerString[47:56]: PillUnsignedVitaminC,
	}
)

// PillUnsignedFromString determines the enum value with an exact case match.
func PillUnsignedFromString(raw string) (PillUnsigned, bool) {
	v, ok := _PillUnsignedStringToValueMap[raw]
	if !ok {
		return PillUnsigned(0), false
	}
	return v, true
}

// PillUnsignedFromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillUnsignedFromStringIgnoreCase(raw string) (PillUnsigned, bool) {
	v, ok := PillUnsignedFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillUnsignedLowerStringToValueMap[raw]
	if !ok {
		return PillUnsigned(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillUnsigned.
func (_p PillUnsigned) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillUnsigned.
func (_p *PillUnsigned) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillUnsigned.
func (_p PillUnsigned) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillUnsigned.
func (_p *PillUnsigned) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillUnsigned.
func (_p PillUnsigned) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillUnsigned.
func (_p *PillUnsigned) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillUnsigned should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillUnsigned.
func (_p PillUnsigned) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillUnsigned. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillUnsigned.
func (_p *PillUnsigned) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillUnsigned.
func (_p PillUnsigned) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillUnsigned.
func (_p *PillUnsigned) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillUnsigned.
func (_p PillUnsigned) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillUnsigned.
func (_p *PillUnsigned) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillUnsigned must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsignedFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned", str)
	}
	return nil
}

const (
	_PillUnsigned16String      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillUnsigned16LowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillUnsigned16Values  = [5]PillUnsigned16{0, 1, 2, 3, 4}
	_PillUnsigned16Strings = [5]string{_PillUnsigned16String[0:7], _PillUnsigned16String[7:14], _PillUnsigned16String[14:23], _PillUnsigned16String[23:34], _PillUnsigned16String[47:56]}
)

// _PillUnsigned16NoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillUnsigned16.
func _PillUnsigned16NoOp() {
	var x [1]struct{}
	_ = x[PillUnsigned16Placebo-(0)]
	_ = x[PillUnsigned16Aspirin-(1)]
	_ = x[PillUnsigned16Ibuprofen-(2)]
	_ = x[PillUnsigned16Paracetamol-(3)]
	_ = x[PillUnsigned16Acetaminophen-(3)]
	_ = x[PillUnsigned16VitaminC-(4)]
}

// PillUnsigned16Values returns all values of the enum.
func PillUnsigned16Values() []PillUnsigned16 {
	cp := _PillUnsigned16Values
	return cp[:]
}

// PillUnsigned16Strings returns a slice of all String values of the enum.
func PillUnsigned16Strings() []string {
	cp := _PillUnsigned16Strings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillUnsigned16) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillUnsigned16) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillUnsigned16(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillUnsigned16(%d) instead.
func (_p PillUnsigned16) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillUnsigned16(%d)", _p)
	}
	idx := uint(_p)
	return _PillUnsigned16Strings[idx]
}

var (
	_PillUnsigned16StringToValueMap = map[string]PillUnsigned16{
		_PillUnsigned16String[0:7]:   PillUnsigned16Placebo,
		_PillUnsigned16String[7:14]:  PillUnsigned16Aspirin,
		_PillUnsigned16String[14:23]: PillUnsigned16Ibuprofen,
		_PillUnsigned16String[23:34]: PillUnsigned16Paracetamol,
		_PillUnsigned16String[34:47]: PillUnsigned16Acetaminophen,
		_PillUnsigned16String[47:56]: PillUnsigned16VitaminC,
	}
	_PillUnsigned16LowerStringToValueMap = map[string]PillUnsigned16{
		_PillUnsigned16LowerString[0:7]:   PillUnsigned16Placebo,
		_PillUnsigned16LowerString[7:14]:  PillUnsigned16Aspirin,
		_PillUnsigned16LowerString[14:23]: PillUnsigned16Ibuprofen,
		_PillUnsigned16LowerString[23:34]: PillUnsigned16Paracetamol,
		_PillUnsigned16LowerString[34:47]: PillUnsigned16Acetaminophen,
		_PillUnsigned16LowerString[47:56]: PillUnsigned16VitaminC,
	}
)

// PillUnsigned16FromString determines the enum value with an exact case match.
func PillUnsigned16FromString(raw string) (PillUnsigned16, bool) {
	v, ok := _PillUnsigned16StringToValueMap[raw]
	if !ok {
		return PillUnsigned16(0), false
	}
	return v, true
}

// PillUnsigned16FromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillUnsigned16FromStringIgnoreCase(raw string) (PillUnsigned16, bool) {
	v, ok := PillUnsigned16FromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillUnsigned16LowerStringToValueMap[raw]
	if !ok {
		return PillUnsigned16(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillUnsigned16.
func (_p PillUnsigned16) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned16. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillUnsigned16.
func (_p *PillUnsigned16) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillUnsigned16.
func (_p PillUnsigned16) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillUnsigned16.
func (_p *PillUnsigned16) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned16: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillUnsigned16.
func (_p PillUnsigned16) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned16. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillUnsigned16.
func (_p *PillUnsigned16) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillUnsigned16 should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillUnsigned16.
func (_p PillUnsigned16) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillUnsigned16. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillUnsigned16.
func (_p *PillUnsigned16) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned16: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillUnsigned16.
func (_p PillUnsigned16) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned16. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillUnsigned16.
func (_p *PillUnsigned16) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillUnsigned16.
func (_p PillUnsigned16) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned16. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillUnsigned16.
func (_p *PillUnsigned16) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillUnsigned16 must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned16 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned16FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned16", str)
	}
	return nil
}

const (
	_PillUnsigned32String      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillUnsigned32LowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillUnsigned32Values  = [5]PillUnsigned32{0, 1, 2, 3, 4}
	_PillUnsigned32Strings = [5]string{_PillUnsigned32String[0:7], _PillUnsigned32String[7:14], _PillUnsigned32String[14:23], _PillUnsigned32String[23:34], _PillUnsigned32String[47:56]}
)

// _PillUnsigned32NoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillUnsigned32.
func _PillUnsigned32NoOp() {
	var x [1]struct{}
	_ = x[PillUnsigned32Placebo-(0)]
	_ = x[PillUnsigned32Aspirin-(1)]
	_ = x[PillUnsigned32Ibuprofen-(2)]
	_ = x[PillUnsigned32Paracetamol-(3)]
	_ = x[PillUnsigned32Acetaminophen-(3)]
	_ = x[PillUnsigned32VitaminC-(4)]
}

// PillUnsigned32Values returns all values of the enum.
func PillUnsigned32Values() []PillUnsigned32 {
	cp := _PillUnsigned32Values
	return cp[:]
}

// PillUnsigned32Strings returns a slice of all String values of the enum.
func PillUnsigned32Strings() []string {
	cp := _PillUnsigned32Strings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillUnsigned32) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillUnsigned32) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillUnsigned32(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillUnsigned32(%d) instead.
func (_p PillUnsigned32) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillUnsigned32(%d)", _p)
	}
	idx := uint(_p)
	return _PillUnsigned32Strings[idx]
}

var (
	_PillUnsigned32StringToValueMap = map[string]PillUnsigned32{
		_PillUnsigned32String[0:7]:   PillUnsigned32Placebo,
		_PillUnsigned32String[7:14]:  PillUnsigned32Aspirin,
		_PillUnsigned32String[14:23]: PillUnsigned32Ibuprofen,
		_PillUnsigned32String[23:34]: PillUnsigned32Paracetamol,
		_PillUnsigned32String[34:47]: PillUnsigned32Acetaminophen,
		_PillUnsigned32String[47:56]: PillUnsigned32VitaminC,
	}
	_PillUnsigned32LowerStringToValueMap = map[string]PillUnsigned32{
		_PillUnsigned32LowerString[0:7]:   PillUnsigned32Placebo,
		_PillUnsigned32LowerString[7:14]:  PillUnsigned32Aspirin,
		_PillUnsigned32LowerString[14:23]: PillUnsigned32Ibuprofen,
		_PillUnsigned32LowerString[23:34]: PillUnsigned32Paracetamol,
		_PillUnsigned32LowerString[34:47]: PillUnsigned32Acetaminophen,
		_PillUnsigned32LowerString[47:56]: PillUnsigned32VitaminC,
	}
)

// PillUnsigned32FromString determines the enum value with an exact case match.
func PillUnsigned32FromString(raw string) (PillUnsigned32, bool) {
	v, ok := _PillUnsigned32StringToValueMap[raw]
	if !ok {
		return PillUnsigned32(0), false
	}
	return v, true
}

// PillUnsigned32FromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillUnsigned32FromStringIgnoreCase(raw string) (PillUnsigned32, bool) {
	v, ok := PillUnsigned32FromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillUnsigned32LowerStringToValueMap[raw]
	if !ok {
		return PillUnsigned32(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillUnsigned32.
func (_p PillUnsigned32) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned32. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillUnsigned32.
func (_p *PillUnsigned32) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillUnsigned32.
func (_p PillUnsigned32) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillUnsigned32.
func (_p *PillUnsigned32) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned32: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillUnsigned32.
func (_p PillUnsigned32) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned32. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillUnsigned32.
func (_p *PillUnsigned32) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillUnsigned32 should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillUnsigned32.
func (_p PillUnsigned32) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillUnsigned32. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillUnsigned32.
func (_p *PillUnsigned32) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned32: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillUnsigned32.
func (_p PillUnsigned32) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned32. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillUnsigned32.
func (_p *PillUnsigned32) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillUnsigned32.
func (_p PillUnsigned32) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned32. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillUnsigned32.
func (_p *PillUnsigned32) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillUnsigned32 must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned32 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned32FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned32", str)
	}
	return nil
}

const (
	_PillUnsigned64String      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillUnsigned64LowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillUnsigned64Values  = [5]PillUnsigned64{0, 1, 2, 3, 4}
	_PillUnsigned64Strings = [5]string{_PillUnsigned64String[0:7], _PillUnsigned64String[7:14], _PillUnsigned64String[14:23], _PillUnsigned64String[23:34], _PillUnsigned64String[47:56]}
)

// _PillUnsigned64NoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillUnsigned64.
func _PillUnsigned64NoOp() {
	var x [1]struct{}
	_ = x[PillUnsigned64Placebo-(0)]
	_ = x[PillUnsigned64Aspirin-(1)]
	_ = x[PillUnsigned64Ibuprofen-(2)]
	_ = x[PillUnsigned64Paracetamol-(3)]
	_ = x[PillUnsigned64Acetaminophen-(3)]
	_ = x[PillUnsigned64VitaminC-(4)]
}

// PillUnsigned64Values returns all values of the enum.
func PillUnsigned64Values() []PillUnsigned64 {
	cp := _PillUnsigned64Values
	return cp[:]
}

// PillUnsigned64Strings returns a slice of all String values of the enum.
func PillUnsigned64Strings() []string {
	cp := _PillUnsigned64Strings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillUnsigned64) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillUnsigned64) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillUnsigned64(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillUnsigned64(%d) instead.
func (_p PillUnsigned64) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillUnsigned64(%d)", _p)
	}
	idx := uint(_p)
	return _PillUnsigned64Strings[idx]
}

var (
	_PillUnsigned64StringToValueMap = map[string]PillUnsigned64{
		_PillUnsigned64String[0:7]:   PillUnsigned64Placebo,
		_PillUnsigned64String[7:14]:  PillUnsigned64Aspirin,
		_PillUnsigned64String[14:23]: PillUnsigned64Ibuprofen,
		_PillUnsigned64String[23:34]: PillUnsigned64Paracetamol,
		_PillUnsigned64String[34:47]: PillUnsigned64Acetaminophen,
		_PillUnsigned64String[47:56]: PillUnsigned64VitaminC,
	}
	_PillUnsigned64LowerStringToValueMap = map[string]PillUnsigned64{
		_PillUnsigned64LowerString[0:7]:   PillUnsigned64Placebo,
		_PillUnsigned64LowerString[7:14]:  PillUnsigned64Aspirin,
		_PillUnsigned64LowerString[14:23]: PillUnsigned64Ibuprofen,
		_PillUnsigned64LowerString[23:34]: PillUnsigned64Paracetamol,
		_PillUnsigned64LowerString[34:47]: PillUnsigned64Acetaminophen,
		_PillUnsigned64LowerString[47:56]: PillUnsigned64VitaminC,
	}
)

// PillUnsigned64FromString determines the enum value with an exact case match.
func PillUnsigned64FromString(raw string) (PillUnsigned64, bool) {
	v, ok := _PillUnsigned64StringToValueMap[raw]
	if !ok {
		return PillUnsigned64(0), false
	}
	return v, true
}

// PillUnsigned64FromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillUnsigned64FromStringIgnoreCase(raw string) (PillUnsigned64, bool) {
	v, ok := PillUnsigned64FromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillUnsigned64LowerStringToValueMap[raw]
	if !ok {
		return PillUnsigned64(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillUnsigned64.
func (_p PillUnsigned64) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned64. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillUnsigned64.
func (_p *PillUnsigned64) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillUnsigned64.
func (_p PillUnsigned64) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillUnsigned64.
func (_p *PillUnsigned64) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned64: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillUnsigned64.
func (_p PillUnsigned64) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned64. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillUnsigned64.
func (_p *PillUnsigned64) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillUnsigned64 should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillUnsigned64.
func (_p PillUnsigned64) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillUnsigned64. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillUnsigned64.
func (_p *PillUnsigned64) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned64: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillUnsigned64.
func (_p PillUnsigned64) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned64. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillUnsigned64.
func (_p *PillUnsigned64) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillUnsigned64.
func (_p PillUnsigned64) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned64. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillUnsigned64.
func (_p *PillUnsigned64) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillUnsigned64 must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned64 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned64FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned64", str)
	}
	return nil
}

const (
	_PillUnsigned8String      = "PLACEBOASPIRINIBUPROFENPARACETAMOLACETAMINOPHENVITAMIN-C"
	_PillUnsigned8LowerString = "placeboaspirinibuprofenparacetamolacetaminophenvitamin-c"
)

var (
	_PillUnsigned8Values  = [5]PillUnsigned8{0, 1, 2, 3, 4}
	_PillUnsigned8Strings = [5]string{_PillUnsigned8String[0:7], _PillUnsigned8String[7:14], _PillUnsigned8String[14:23], _PillUnsigned8String[23:34], _PillUnsigned8String[47:56]}
)

// _PillUnsigned8NoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of PillUnsigned8.
func _PillUnsigned8NoOp() {
	var x [1]struct{}
	_ = x[PillUnsigned8Placebo-(0)]
	_ = x[PillUnsigned8Aspirin-(1)]
	_ = x[PillUnsigned8Ibuprofen-(2)]
	_ = x[PillUnsigned8Paracetamol-(3)]
	_ = x[PillUnsigned8Acetaminophen-(3)]
	_ = x[PillUnsigned8VitaminC-(4)]
}

// PillUnsigned8Values returns all values of the enum.
func PillUnsigned8Values() []PillUnsigned8 {
	cp := _PillUnsigned8Values
	return cp[:]
}

// PillUnsigned8Strings returns a slice of all String values of the enum.
func PillUnsigned8Strings() []string {
	cp := _PillUnsigned8Strings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_p PillUnsigned8) IsValid() bool {
	return _p >= 0 && _p <= 4
}

// Validate whether the value is within the range of enum values.
func (_p PillUnsigned8) Validate() error {
	if !_p.IsValid() {
		return fmt.Errorf("PillUnsigned8(%d) is %w", _p, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern PillUnsigned8(%d) instead.
func (_p PillUnsigned8) String() string {
	if !_p.IsValid() {
		return fmt.Sprintf("PillUnsigned8(%d)", _p)
	}
	idx := uint(_p)
	return _PillUnsigned8Strings[idx]
}

var (
	_PillUnsigned8StringToValueMap = map[string]PillUnsigned8{
		_PillUnsigned8String[0:7]:   PillUnsigned8Placebo,
		_PillUnsigned8String[7:14]:  PillUnsigned8Aspirin,
		_PillUnsigned8String[14:23]: PillUnsigned8Ibuprofen,
		_PillUnsigned8String[23:34]: PillUnsigned8Paracetamol,
		_PillUnsigned8String[34:47]: PillUnsigned8Acetaminophen,
		_PillUnsigned8String[47:56]: PillUnsigned8VitaminC,
	}
	_PillUnsigned8LowerStringToValueMap = map[string]PillUnsigned8{
		_PillUnsigned8LowerString[0:7]:   PillUnsigned8Placebo,
		_PillUnsigned8LowerString[7:14]:  PillUnsigned8Aspirin,
		_PillUnsigned8LowerString[14:23]: PillUnsigned8Ibuprofen,
		_PillUnsigned8LowerString[23:34]: PillUnsigned8Paracetamol,
		_PillUnsigned8LowerString[34:47]: PillUnsigned8Acetaminophen,
		_PillUnsigned8LowerString[47:56]: PillUnsigned8VitaminC,
	}
)

// PillUnsigned8FromString determines the enum value with an exact case match.
func PillUnsigned8FromString(raw string) (PillUnsigned8, bool) {
	v, ok := _PillUnsigned8StringToValueMap[raw]
	if !ok {
		return PillUnsigned8(0), false
	}
	return v, true
}

// PillUnsigned8FromStringIgnoreCase determines the enum value with a case-insensitive match.
func PillUnsigned8FromStringIgnoreCase(raw string) (PillUnsigned8, bool) {
	v, ok := PillUnsigned8FromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _PillUnsigned8LowerStringToValueMap[raw]
	if !ok {
		return PillUnsigned8(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for PillUnsigned8.
func (_p PillUnsigned8) MarshalBinary() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned8. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for PillUnsigned8.
func (_p *PillUnsigned8) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for PillUnsigned8.
func (_p PillUnsigned8) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_p.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for PillUnsigned8.
func (_p *PillUnsigned8) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned8: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for PillUnsigned8.
func (_p PillUnsigned8) MarshalJSON() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned8. %w", _p, err)
	}
	return json.Marshal(_p.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for PillUnsigned8.
func (_p *PillUnsigned8) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("PillUnsigned8 should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for PillUnsigned8.
func (_p PillUnsigned8) Value() (driver.Value, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as PillUnsigned8. %w", _p, err)
	}
	return _p.String(), nil
}

// Scan implements the sql/driver.Scanner interface for PillUnsigned8.
func (_p *PillUnsigned8) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of PillUnsigned8: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for PillUnsigned8.
func (_p PillUnsigned8) MarshalText() ([]byte, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned8. %w", _p, err)
	}
	return []byte(_p.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for PillUnsigned8.
func (_p *PillUnsigned8) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for PillUnsigned8.
func (_p PillUnsigned8) MarshalYAML() (interface{}, error) {
	if err := _p.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as PillUnsigned8. %w", _p, err)
	}
	return _p.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for PillUnsigned8.
func (_p *PillUnsigned8) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("PillUnsigned8 must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("PillUnsigned8 cannot be derived from empty string")
	}

	var ok bool
	*_p, ok = PillUnsigned8FromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a PillUnsigned8", str)
	}
	return nil
}
