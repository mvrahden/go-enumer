// Code generated by "go-enumer (github.com/mvrahden/go-enumer)"; DO NOT EDIT.

package animals

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"gopkg.in/yaml.v3"
	"io"
	"strconv"
)

var (
	ErrNoValidEnum = errors.New("not a valid enum")
)

const (
	_AnimalString      = "DogCatSealSeaLionIceBear"
	_AnimalLowerString = "dogcatsealsealionicebear"
)

var (
	_AnimalValues  = [5]Animal{0, 1, 2, 3, 4}
	_AnimalStrings = [5]string{_AnimalString[0:3], _AnimalString[3:6], _AnimalString[6:10], _AnimalString[10:17], _AnimalString[17:24]}
)

// _AnimalNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of Animal.
func _AnimalNoOp() {
	var x [1]struct{}
	_ = x[AnimalDog-(0)]
	_ = x[AnimalCat-(1)]
	_ = x[AnimalSeal-(2)]
	_ = x[AnimalSeaLion-(3)]
	_ = x[AnimalIceBear-(4)]
}

// AnimalValues returns all values of the enum.
func AnimalValues() []Animal {
	cp := _AnimalValues
	return cp[:]
}

// AnimalStrings returns a slice of all String values of the enum.
func AnimalStrings() []string {
	cp := _AnimalStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_a Animal) IsValid() bool {
	return _a >= 0 && _a <= 4
}

// Validate whether the value is within the range of enum values.
func (_a Animal) Validate() error {
	if !_a.IsValid() {
		return fmt.Errorf("Animal(%d) is %w", _a, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern Animal(%d) instead.
func (_a Animal) String() string {
	if !_a.IsValid() {
		return fmt.Sprintf("Animal(%d)", _a)
	}
	idx := uint(_a)
	return _AnimalStrings[idx]
}

var (
	_AnimalStringToValueMap = map[string]Animal{
		_AnimalString[0:3]:   AnimalDog,
		_AnimalString[3:6]:   AnimalCat,
		_AnimalString[6:10]:  AnimalSeal,
		_AnimalString[10:17]: AnimalSeaLion,
		_AnimalString[17:24]: AnimalIceBear,
	}
	_AnimalLowerStringToValueMap = map[string]Animal{
		_AnimalLowerString[0:3]:   AnimalDog,
		_AnimalLowerString[3:6]:   AnimalCat,
		_AnimalLowerString[6:10]:  AnimalSeal,
		_AnimalLowerString[10:17]: AnimalSeaLion,
		_AnimalLowerString[17:24]: AnimalIceBear,
	}
)

// AnimalFromString determines the enum value with an exact case match.
func AnimalFromString(raw string) (Animal, bool) {
	v, ok := _AnimalStringToValueMap[raw]
	if !ok {
		return Animal(0), false
	}
	return v, true
}

// AnimalFromStringIgnoreCase determines the enum value with a case-insensitive match.
func AnimalFromStringIgnoreCase(raw string) (Animal, bool) {
	v, ok := AnimalFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _AnimalLowerStringToValueMap[raw]
	if !ok {
		return Animal(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Animal.
func (_a Animal) MarshalBinary() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Animal. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Animal.
func (_a *Animal) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Animal.
func (_a Animal) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_a.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Animal.
func (_a *Animal) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Animal: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for Animal.
func (_a Animal) MarshalJSON() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Animal. %w", _a, err)
	}
	return json.Marshal(_a.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Animal.
func (_a *Animal) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("Animal should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for Animal.
func (_a Animal) Value() (driver.Value, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as Animal. %w", _a, err)
	}
	return _a.String(), nil
}

// Scan implements the sql/driver.Scanner interface for Animal.
func (_a *Animal) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Animal: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Animal.
func (_a Animal) MarshalText() ([]byte, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Animal. %w", _a, err)
	}
	return []byte(_a.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Animal.
func (_a *Animal) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for Animal.
func (_a Animal) MarshalYAML() (interface{}, error) {
	if err := _a.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Animal. %w", _a, err)
	}
	return _a.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Animal.
func (_a *Animal) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("Animal must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("Animal cannot be derived from empty string")
	}

	var ok bool
	*_a, ok = AnimalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Animal", str)
	}
	return nil
}

const (
	_BirdString      = "ALBATROSSHUMMING_BIRDDARWINS_FINCHOSTRICHKING_FISHER"
	_BirdLowerString = "albatrosshumming_birddarwins_finchostrichking_fisher"
)

var (
	_BirdValues  = [5]Bird{0, 1, 2, 3, 4}
	_BirdStrings = [5]string{_BirdString[0:9], _BirdString[9:21], _BirdString[21:34], _BirdString[34:41], _BirdString[41:52]}
)

// _BirdNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of Bird.
func _BirdNoOp() {
	var x [1]struct{}
	_ = x[BirdAlbatross-(0)]
	_ = x[BirdHummingBird-(1)]
	_ = x[BirdDarwinsFinch-(2)]
	_ = x[BirdOstrich-(3)]
	_ = x[BirdKingFisher-(4)]
}

// BirdValues returns all values of the enum.
func BirdValues() []Bird {
	cp := _BirdValues
	return cp[:]
}

// BirdStrings returns a slice of all String values of the enum.
func BirdStrings() []string {
	cp := _BirdStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_b Bird) IsValid() bool {
	return _b >= 0 && _b <= 4
}

// Validate whether the value is within the range of enum values.
func (_b Bird) Validate() error {
	if !_b.IsValid() {
		return fmt.Errorf("Bird(%d) is %w", _b, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern Bird(%d) instead.
func (_b Bird) String() string {
	if !_b.IsValid() {
		return fmt.Sprintf("Bird(%d)", _b)
	}
	idx := uint(_b)
	return _BirdStrings[idx]
}

var (
	_BirdStringToValueMap = map[string]Bird{
		_BirdString[0:9]:   BirdAlbatross,
		_BirdString[9:21]:  BirdHummingBird,
		_BirdString[21:34]: BirdDarwinsFinch,
		_BirdString[34:41]: BirdOstrich,
		_BirdString[41:52]: BirdKingFisher,
	}
	_BirdLowerStringToValueMap = map[string]Bird{
		_BirdLowerString[0:9]:   BirdAlbatross,
		_BirdLowerString[9:21]:  BirdHummingBird,
		_BirdLowerString[21:34]: BirdDarwinsFinch,
		_BirdLowerString[34:41]: BirdOstrich,
		_BirdLowerString[41:52]: BirdKingFisher,
	}
)

// BirdFromString determines the enum value with an exact case match.
func BirdFromString(raw string) (Bird, bool) {
	v, ok := _BirdStringToValueMap[raw]
	if !ok {
		return Bird(0), false
	}
	return v, true
}

// BirdFromStringIgnoreCase determines the enum value with a case-insensitive match.
func BirdFromStringIgnoreCase(raw string) (Bird, bool) {
	v, ok := BirdFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _BirdLowerStringToValueMap[raw]
	if !ok {
		return Bird(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Bird.
func (_b Bird) MarshalBinary() ([]byte, error) {
	if err := _b.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Bird. %w", _b, err)
	}
	return []byte(_b.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Bird.
func (_b *Bird) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Bird.
func (_b Bird) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_b.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Bird.
func (_b *Bird) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Bird: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for Bird.
func (_b Bird) MarshalJSON() ([]byte, error) {
	if err := _b.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Bird. %w", _b, err)
	}
	return json.Marshal(_b.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Bird.
func (_b *Bird) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("Bird should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for Bird.
func (_b Bird) Value() (driver.Value, error) {
	if err := _b.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as Bird. %w", _b, err)
	}
	return _b.String(), nil
}

// Scan implements the sql/driver.Scanner interface for Bird.
func (_b *Bird) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Bird: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Bird.
func (_b Bird) MarshalText() ([]byte, error) {
	if err := _b.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Bird. %w", _b, err)
	}
	return []byte(_b.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Bird.
func (_b *Bird) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for Bird.
func (_b Bird) MarshalYAML() (interface{}, error) {
	if err := _b.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Bird. %w", _b, err)
	}
	return _b.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Bird.
func (_b *Bird) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("Bird must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("Bird cannot be derived from empty string")
	}

	var ok bool
	*_b, ok = BirdFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Bird", str)
	}
	return nil
}

const (
	_FishString      = "giant_grouperhagfishreedfishbowfincatfishhorn_shark"
	_FishLowerString = "giant_grouperhagfishreedfishbowfincatfishhorn_shark"
)

var (
	_FishValues  = [6]Fish{0, 1, 2, 3, 4, 5}
	_FishStrings = [6]string{_FishString[0:13], _FishString[13:20], _FishString[20:28], _FishString[28:34], _FishString[34:41], _FishString[41:51]}
)

// _FishNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of Fish.
func _FishNoOp() {
	var x [1]struct{}
	_ = x[FishGiantGrouper-(0)]
	_ = x[FishHagfish-(1)]
	_ = x[FishReedfish-(2)]
	_ = x[FishBowfin-(3)]
	_ = x[FishCatfish-(4)]
	_ = x[FishHornShark-(5)]
}

// FishValues returns all values of the enum.
func FishValues() []Fish {
	cp := _FishValues
	return cp[:]
}

// FishStrings returns a slice of all String values of the enum.
func FishStrings() []string {
	cp := _FishStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_f Fish) IsValid() bool {
	return _f >= 0 && _f <= 5
}

// Validate whether the value is within the range of enum values.
func (_f Fish) Validate() error {
	if !_f.IsValid() {
		return fmt.Errorf("Fish(%d) is %w", _f, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern Fish(%d) instead.
func (_f Fish) String() string {
	if !_f.IsValid() {
		return fmt.Sprintf("Fish(%d)", _f)
	}
	idx := uint(_f)
	return _FishStrings[idx]
}

var (
	_FishStringToValueMap = map[string]Fish{
		_FishString[0:13]:  FishGiantGrouper,
		_FishString[13:20]: FishHagfish,
		_FishString[20:28]: FishReedfish,
		_FishString[28:34]: FishBowfin,
		_FishString[34:41]: FishCatfish,
		_FishString[41:51]: FishHornShark,
	}
	_FishLowerStringToValueMap = map[string]Fish{
		_FishLowerString[0:13]:  FishGiantGrouper,
		_FishLowerString[13:20]: FishHagfish,
		_FishLowerString[20:28]: FishReedfish,
		_FishLowerString[28:34]: FishBowfin,
		_FishLowerString[34:41]: FishCatfish,
		_FishLowerString[41:51]: FishHornShark,
	}
)

// FishFromString determines the enum value with an exact case match.
func FishFromString(raw string) (Fish, bool) {
	v, ok := _FishStringToValueMap[raw]
	if !ok {
		return Fish(0), false
	}
	return v, true
}

// FishFromStringIgnoreCase determines the enum value with a case-insensitive match.
func FishFromStringIgnoreCase(raw string) (Fish, bool) {
	v, ok := FishFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _FishLowerStringToValueMap[raw]
	if !ok {
		return Fish(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Fish.
func (_f Fish) MarshalBinary() ([]byte, error) {
	if err := _f.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Fish. %w", _f, err)
	}
	return []byte(_f.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Fish.
func (_f *Fish) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Fish.
func (_f Fish) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_f.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Fish.
func (_f *Fish) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Fish: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for Fish.
func (_f Fish) MarshalJSON() ([]byte, error) {
	if err := _f.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Fish. %w", _f, err)
	}
	return json.Marshal(_f.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Fish.
func (_f *Fish) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("Fish should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for Fish.
func (_f Fish) Value() (driver.Value, error) {
	if err := _f.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as Fish. %w", _f, err)
	}
	return _f.String(), nil
}

// Scan implements the sql/driver.Scanner interface for Fish.
func (_f *Fish) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Fish: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Fish.
func (_f Fish) MarshalText() ([]byte, error) {
	if err := _f.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Fish. %w", _f, err)
	}
	return []byte(_f.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Fish.
func (_f *Fish) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for Fish.
func (_f Fish) MarshalYAML() (interface{}, error) {
	if err := _f.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Fish. %w", _f, err)
	}
	return _f.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Fish.
func (_f *Fish) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("Fish must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("Fish cannot be derived from empty string")
	}

	var ok bool
	*_f, ok = FishFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Fish", str)
	}
	return nil
}

const (
	_MammalString      = "BUMBLEBEE-BATBLUE-WHALEBOWHEAD-WHALE"
	_MammalLowerString = "bumblebee-batblue-whalebowhead-whale"
)

var (
	_MammalValues  = [3]Mammal{0, 1, 2}
	_MammalStrings = [3]string{_MammalString[0:13], _MammalString[13:23], _MammalString[23:36]}
)

// _MammalNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of Mammal.
func _MammalNoOp() {
	var x [1]struct{}
	_ = x[MammalBumblebeeBat-(0)]
	_ = x[MammalBlueWhale-(1)]
	_ = x[MammalBowheadWhale-(2)]
}

// MammalValues returns all values of the enum.
func MammalValues() []Mammal {
	cp := _MammalValues
	return cp[:]
}

// MammalStrings returns a slice of all String values of the enum.
func MammalStrings() []string {
	cp := _MammalStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_m Mammal) IsValid() bool {
	return _m >= 0 && _m <= 2
}

// Validate whether the value is within the range of enum values.
func (_m Mammal) Validate() error {
	if !_m.IsValid() {
		return fmt.Errorf("Mammal(%d) is %w", _m, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern Mammal(%d) instead.
func (_m Mammal) String() string {
	if !_m.IsValid() {
		return fmt.Sprintf("Mammal(%d)", _m)
	}
	idx := uint(_m)
	return _MammalStrings[idx]
}

var (
	_MammalStringToValueMap = map[string]Mammal{
		_MammalString[0:13]:  MammalBumblebeeBat,
		_MammalString[13:23]: MammalBlueWhale,
		_MammalString[23:36]: MammalBowheadWhale,
	}
	_MammalLowerStringToValueMap = map[string]Mammal{
		_MammalLowerString[0:13]:  MammalBumblebeeBat,
		_MammalLowerString[13:23]: MammalBlueWhale,
		_MammalLowerString[23:36]: MammalBowheadWhale,
	}
)

// MammalFromString determines the enum value with an exact case match.
func MammalFromString(raw string) (Mammal, bool) {
	v, ok := _MammalStringToValueMap[raw]
	if !ok {
		return Mammal(0), false
	}
	return v, true
}

// MammalFromStringIgnoreCase determines the enum value with a case-insensitive match.
func MammalFromStringIgnoreCase(raw string) (Mammal, bool) {
	v, ok := MammalFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _MammalLowerStringToValueMap[raw]
	if !ok {
		return Mammal(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Mammal.
func (_m Mammal) MarshalBinary() ([]byte, error) {
	if err := _m.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Mammal. %w", _m, err)
	}
	return []byte(_m.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Mammal.
func (_m *Mammal) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Mammal.
func (_m Mammal) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_m.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Mammal.
func (_m *Mammal) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Mammal: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for Mammal.
func (_m Mammal) MarshalJSON() ([]byte, error) {
	if err := _m.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Mammal. %w", _m, err)
	}
	return json.Marshal(_m.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Mammal.
func (_m *Mammal) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("Mammal should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for Mammal.
func (_m Mammal) Value() (driver.Value, error) {
	if err := _m.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as Mammal. %w", _m, err)
	}
	return _m.String(), nil
}

// Scan implements the sql/driver.Scanner interface for Mammal.
func (_m *Mammal) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Mammal: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Mammal.
func (_m Mammal) MarshalText() ([]byte, error) {
	if err := _m.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Mammal. %w", _m, err)
	}
	return []byte(_m.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Mammal.
func (_m *Mammal) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for Mammal.
func (_m Mammal) MarshalYAML() (interface{}, error) {
	if err := _m.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Mammal. %w", _m, err)
	}
	return _m.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Mammal.
func (_m *Mammal) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("Mammal must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("Mammal cannot be derived from empty string")
	}

	var ok bool
	*_m, ok = MammalFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Mammal", str)
	}
	return nil
}

const (
	_ReptileString      = "saltwaterCrocodilebeardedDragonchameleoncomodoDragon"
	_ReptileLowerString = "saltwatercrocodilebeardeddragonchameleoncomododragon"
)

var (
	_ReptileValues  = [4]Reptile{0, 1, 2, 3}
	_ReptileStrings = [4]string{_ReptileString[0:18], _ReptileString[18:31], _ReptileString[31:40], _ReptileString[40:52]}
)

// _ReptileNoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of Reptile.
func _ReptileNoOp() {
	var x [1]struct{}
	_ = x[ReptileSaltwaterCrocodile-(0)]
	_ = x[ReptileBeardedDragon-(1)]
	_ = x[ReptileChameleon-(2)]
	_ = x[ReptileComodoDragon-(3)]
}

// ReptileValues returns all values of the enum.
func ReptileValues() []Reptile {
	cp := _ReptileValues
	return cp[:]
}

// ReptileStrings returns a slice of all String values of the enum.
func ReptileStrings() []string {
	cp := _ReptileStrings
	return cp[:]
}

// IsValid tests whether the value is a valid enum value.
func (_r Reptile) IsValid() bool {
	return _r >= 0 && _r <= 3
}

// Validate whether the value is within the range of enum values.
func (_r Reptile) Validate() error {
	if !_r.IsValid() {
		return fmt.Errorf("Reptile(%d) is %w", _r, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern Reptile(%d) instead.
func (_r Reptile) String() string {
	if !_r.IsValid() {
		return fmt.Sprintf("Reptile(%d)", _r)
	}
	idx := uint(_r)
	return _ReptileStrings[idx]
}

var (
	_ReptileStringToValueMap = map[string]Reptile{
		_ReptileString[0:18]:  ReptileSaltwaterCrocodile,
		_ReptileString[18:31]: ReptileBeardedDragon,
		_ReptileString[31:40]: ReptileChameleon,
		_ReptileString[40:52]: ReptileComodoDragon,
	}
	_ReptileLowerStringToValueMap = map[string]Reptile{
		_ReptileLowerString[0:18]:  ReptileSaltwaterCrocodile,
		_ReptileLowerString[18:31]: ReptileBeardedDragon,
		_ReptileLowerString[31:40]: ReptileChameleon,
		_ReptileLowerString[40:52]: ReptileComodoDragon,
	}
)

// ReptileFromString determines the enum value with an exact case match.
func ReptileFromString(raw string) (Reptile, bool) {
	v, ok := _ReptileStringToValueMap[raw]
	if !ok {
		return Reptile(0), false
	}
	return v, true
}

// ReptileFromStringIgnoreCase determines the enum value with a case-insensitive match.
func ReptileFromStringIgnoreCase(raw string) (Reptile, bool) {
	v, ok := ReptileFromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _ReptileLowerStringToValueMap[raw]
	if !ok {
		return Reptile(0), false
	}
	return v, true
}

// MarshalBinary implements the encoding.BinaryMarshaler interface for Reptile.
func (_r Reptile) MarshalBinary() ([]byte, error) {
	if err := _r.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Reptile. %w", _r, err)
	}
	return []byte(_r.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for Reptile.
func (_r *Reptile) UnmarshalBinary(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}

// MarshalGQL implements the graphql.Marshaler interface for Reptile.
func (_r Reptile) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(_r.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for Reptile.
func (_r *Reptile) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Reptile: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}

// MarshalJSON implements the json.Marshaler interface for Reptile.
func (_r Reptile) MarshalJSON() ([]byte, error) {
	if err := _r.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Reptile. %w", _r, err)
	}
	return json.Marshal(_r.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Reptile.
func (_r *Reptile) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("Reptile should be a string, got %q", data)
	}
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}

// Value implements the sql/driver.Valuer interface for Reptile.
func (_r Reptile) Value() (driver.Value, error) {
	if err := _r.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as Reptile. %w", _r, err)
	}
	return _r.String(), nil
}

// Scan implements the sql/driver.Scanner interface for Reptile.
func (_r *Reptile) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of Reptile: %[1]T(%[1]v)", value)
	}
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}

// MarshalText implements the encoding.TextMarshaler interface for Reptile.
func (_r Reptile) MarshalText() ([]byte, error) {
	if err := _r.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Reptile. %w", _r, err)
	}
	return []byte(_r.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for Reptile.
func (_r *Reptile) UnmarshalText(text []byte) error {
	str := string(text)
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}

// MarshalYAML implements a YAML Marshaler for Reptile.
func (_r Reptile) MarshalYAML() (interface{}, error) {
	if err := _r.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as Reptile. %w", _r, err)
	}
	return _r.String(), nil
}

// UnmarshalYAML implements a YAML Unmarshaler for Reptile.
func (_r *Reptile) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("Reptile must be derived from a string node")
	}
	str := n.Value
	if len(str) == 0 {
		return fmt.Errorf("Reptile cannot be derived from empty string")
	}

	var ok bool
	*_r, ok = ReptileFromString(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a Reptile", str)
	}
	return nil
}
