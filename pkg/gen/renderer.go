package gen

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/ettle/strcase"
	"github.com/mvrahden/go-enumer/about"
	"github.com/mvrahden/go-enumer/config"
	"github.com/mvrahden/go-enumer/pkg/utils/slices"
)

type renderer struct{}

func NewRenderer(cfg *config.Options) *renderer {
	r := renderer{}
	return &r
}

func newRenderUtil(cfg *config.Options) *renderUtil {
	r := renderUtil{}
	for _, fn := range []renderUtilOpt{withDefaults, withTransformStrategy, withSupportedFeatures} {
		fn(&r, cfg)
	}
	return &r
}

type renderUtilOpt func(r *renderUtil, c *config.Options)

func withDefaults(r *renderUtil, c *config.Options) {
	r.cfg = c
	r.transform = noopCaseTransformer
}

func withTransformStrategy(r *renderUtil, c *config.Options) {
	r.transform = getTransformStrategy(c)
}

func withSupportedFeatures(r *renderUtil, c *config.Options) {
	r.supportUndefined = c.SupportedFeatures.Contains(config.SupportUndefined)
	r.supportEntInterface = c.SupportedFeatures.Contains(config.SupportEntInterface)
}

func (r *renderer) Render(f *File) ([]byte, error) {
	buf := new(bytes.Buffer)

	{ // write file header
		tpl := template.Must(template.New("header").Parse(`
{{- /* Declaration of file header */ -}}
// Code generated by "{{ .RepoName }}"; DO NOT EDIT.

package {{ .PackageName }}

{{/* Declaration of file imports */}}
{{- if .Imports -}}
import (
{{- range $i := .Imports }}
	{{ if $i.Name }}{{ $i.Name }} {{ end -}}
	{{ printf "%q" $i.Path }}
{{- end }}
)
{{- end }}

{{/* Declaration of enum specific error */}}
{{- if .ContainsErrorsPkg -}}
var (
	ErrNoValidEnum = errors.New("not a valid enum")
)

{{ end }}`))

		type TplHeader struct {
			RepoName          string
			PackageName       string
			Imports           []*Import
			ContainsErrorsPkg bool
		}
		tplData := TplHeader{
			RepoName:    about.ShortInfo(),
			PackageName: f.Header.Package.Name,
			Imports:     f.Imports,
			ContainsErrorsPkg: slices.Any(f.Imports, func(v *Import) bool {
				return v.Path == "errors"
			}),
		}
		err := tpl.Execute(buf, tplData)
		if err != nil {
			return nil, fmt.Errorf("failed rendering file header. err: %w", err)
		}
	}

	idx, err := slices.RangeErr(f.TypeSpecs, func(ts *TypeSpec, _ int) error {
		return r.renderForTypeSpec(buf, ts)
	})
	if err != nil {
		return nil, fmt.Errorf("failed rendering sources for %q. err: %w", f.TypeSpecs[idx].Name, err)
	}
	return buf.Bytes(), nil
}

var tplFuncs = template.FuncMap{
	"add": func(a, b int) int {
		return a + b
	},
	"sub": func(a, b int) int {
		return a - b
	},
	"lower":  lowerCaseTransformer,
	"pascal": pascalCaseTransformer,
	"receiver": func(s string) string {
		for _, v := range s {
			return "_" + strings.ToLower(string(v)) // take first rune
		}
		return "_x" // fallback
	},
	"zero": func(t GoType) string {
		return t.ZeroValueString()
	},
}

func (r *renderer) renderForTypeSpec(buf *bytes.Buffer, ts *TypeSpec) error {
	if ts.IsFromCsvSource {
		ts.Config.TransformStrategy = "noop"
	}

	util := newRenderUtil(ts.Config)

	for _, v := range ts.ValueSpecs {
		v.EnumValue = util.transform(v.EnumValue)
	}

	requiresGeneratedUndefinedValue := ts.Config.SupportedFeatures.Contains(config.SupportUndefined) &&
		slices.None(ts.ValueSpecs, func(v *ValueSpec) bool { return v.Value == 0 })

	{ // write consts
		type ConstTypeSpec struct {
			Name                            string
			AggregatedValueStrings          string // hint: aggregation of all enum string representations
			RequiresGeneratedUndefinedValue bool
		}
		type ConstTemplate struct {
			Type ConstTypeSpec
		}

		constsTpl := template.Must(template.New("consts").Funcs(tplFuncs).Parse(`
{{- /* Declaration of enum's base constants */ -}}
{{- with $ts := .Type -}}
const (
	_{{ $ts.Name }}String      = "{{ $ts.AggregatedValueStrings }}"
	_{{ $ts.Name }}LowerString = "{{ lower $ts.AggregatedValueStrings }}"
{{- if $ts.RequiresGeneratedUndefinedValue }}

	// {{ $ts.Name }}Undefined is the generated zero value of the {{ $ts.Name }} enum.
	{{ $ts.Name }}Undefined {{ $ts.Name }} = 0
{{- end }}
)
{{- end }}

`))

		aggregatedValueStrings := slices.ReduceSeed(ts.ValueSpecs, bytes.Buffer{}, func(v *ValueSpec, acc bytes.Buffer) bytes.Buffer {
			acc.WriteString(v.EnumValue)
			return acc
		})

		err := constsTpl.ExecuteTemplate(buf, "consts", ConstTemplate{
			Type: ConstTypeSpec{
				Name:                            ts.Name,
				AggregatedValueStrings:          aggregatedValueStrings.String(),
				RequiresGeneratedUndefinedValue: requiresGeneratedUndefinedValue,
			},
		})
		if err != nil {
			return err
		}
	}

	type AdditionalDataHeader struct {
		Name string // hint: the column name as-is (from CSV)
		Type GoType // hint: the type infered by type syntax
	}
	type AdditionalDataCell struct {
		Value string // hint: source representation of the value, e.g. literal strings are quoted
	}
	type AdditionalData struct {
		Headers []AdditionalDataHeader
		Rows    [][]AdditionalDataCell
	}
	type EnumValue struct {
		Value              uint64 // hint: the enum's numeric representation
		String             string // hint: the enum's string representation
		ConstName          string // hint: the enum's constant name
		Position           int    // hint: start index of enum value string within enum aggregate string
		Length             int    // hint: length of
		IsAlternativeValue bool   // hint: is the enum an alternative value
	}

	{ // write vars
		type EnumSetRange struct {
			LowerBound uint64 // hint: the lower numerical bound of the enum set
			UpperBound uint64 // hint: the upper numerical bound of the enum set
		}
		type VarsTypeSpec struct {
			Name              string       // hint: enum type name
			UniqueValues      int          // hint: count of all enums, less the alternative values
			Range             EnumSetRange // hint: range of the enum set
			Values            []EnumValue  // hint: the enum set, less the alternative values
			HasAdditionalData bool
			AdditionalData    AdditionalData
		}
		type VarsTemplate struct {
			Type VarsTypeSpec
		}
		varsTpl := template.Must(template.New("vars").Funcs(tplFuncs).Parse(`
{{- /* Declaration of enum's base variables */ -}}
{{- with $ts := .Type -}}
var (
	_{{ $ts.Name }}ValueRange = [2]{{ $ts.Name }}{ {{- $ts.Range.LowerBound }}, {{ $ts.Range.UpperBound -}}}
	_{{ $ts.Name }}Values     = [{{ $ts.UniqueValues }}]{{ $ts.Name }}{
		{{- range $idx, $v := $ts.Values }}
			{{- if $v.IsAlternativeValue }}{{continue}}{{ end -}}
			{{- $isNotlast := sub (len $ts.Values) 1 | lt $idx -}}
			{{- $v.Value }}
			{{- if $isNotlast }}, {{ end -}}
		{{- end -}}}
	_{{ $ts.Name }}Strings    = [{{ $ts.UniqueValues }}]string{
	{{- range $idx, $v := $ts.Values }}
		{{- if $v.IsAlternativeValue }}{{continue}}{{ end -}}
		{{- $isNotlast := sub (len $ts.Values) 1 | lt $idx -}}
		_{{ $ts.Name }}String[{{ $v.Position }}:{{ add $v.Position $v.Length }}]
		{{- if $isNotlast }}, {{ end -}}
	{{- end -}}}
{{- /* Declaration of enum's additional data */ -}}
{{- if $ts.HasAdditionalData }}
	_{{ $ts.Name }}AdditionalData  = [{{ $ts.UniqueValues }}]struct{
	{{- range $h := $ts.AdditionalData.Headers }}
		{{ pascal $h.Name }} {{ $h.Type }}
	{{- end }}
	}{
	{{- range $ridx, $r := $ts.AdditionalData.Rows }}
		{
		{{- range $cidx, $c := $r }}
			{{- $isNotLastCell := sub (len $r) 1 | lt $cidx }}
			{{- $c.Value }}{{ if $isNotLastCell }}, {{ end }}
		{{- end -}}
		},
	{{- end }}
	}
{{- end }}
)
{{- end }}

`))
		uniqueValues := slices.Filter(ts.ValueSpecs, func(v *ValueSpec, idx int) bool {
			if idx == 0 {
				return true
			}
			return v.Value != ts.ValueSpecs[idx-1].Value
		})
		lowerBound := ts.ValueSpecs[0].Value
		if requiresGeneratedUndefinedValue {
			lowerBound = 0
		}
		err := varsTpl.ExecuteTemplate(buf, "vars", VarsTemplate{
			Type: VarsTypeSpec{
				Name:         ts.Name,
				UniqueValues: len(uniqueValues),
				Range: EnumSetRange{
					LowerBound: lowerBound,
					UpperBound: ts.ValueSpecs[len(ts.ValueSpecs)-1].Value,
				},
				Values: slices.Map(ts.ValueSpecs, func(v *ValueSpec, idx int) EnumValue {
					var isAlternativeValue bool
					if idx > 0 {
						isAlternativeValue = v.Value == ts.ValueSpecs[idx-1].Value
					}
					return EnumValue{
						Value:     v.Value,
						String:    v.EnumValue,
						ConstName: v.IdentifierName,
						Position: slices.Reduce(ts.ValueSpecs[0:idx], func(v *ValueSpec, acc int) int {
							return acc + len(v.EnumValue)
						}),
						Length:             len(v.EnumValue),
						IsAlternativeValue: isAlternativeValue,
					}
				}),
				HasAdditionalData: ts.HasAdditionalData,
				AdditionalData: AdditionalData{
					Headers: slices.Map(ts.DataColumns, func(v DataHeader, idx int) AdditionalDataHeader {
						return AdditionalDataHeader{v.Name, v.Type}
					}),
					Rows: slices.Map(ts.ValueSpecs, func(v *ValueSpec, rowIdx int) []AdditionalDataCell {
						return slices.Map(v.DataCells, func(v DataCell, colIdx int) AdditionalDataCell {
							return AdditionalDataCell{ts.DataColumns[colIdx].Type.ToSource(v.ValueString)}
						})
					}),
				},
			},
		})
		if err != nil {
			return err
		}
	}

	if !ts.IsFromCsvSource { // compiletime assertion
		tpl := template.Must(template.New("assertions").Funcs(tplFuncs).Parse(`
{{- /* Declare compile time assertion of enum set constants */ -}}
{{- with $ts := .Type -}}
{{- if not $ts.IsFromCsvSource }}
// _{{ $ts.Name }}NoOp is a compile time assertion.
// An "invalid argument/out of bounds" compiler error signifies that the enum values have changed.
// Re-run the enumer command to generate an updated version of {{ $ts.Name }}.
func _{{ $ts.Name }}NoOp() {
	var x [1]struct{}
{{- if $ts.RequiresGeneratedUndefinedValue }}
	_ = x[{{ $ts.Name }}Undefined-(0)]
{{- end }}
{{- range $v := $ts.ValueSpecs }}
	_ = x[{{ $v.IdentifierName }}-({{ $v.Value }})]
{{- end }}
{{- end }}
}

{{ end }}`))
		tpl.Execute(buf, map[string]any{
			"Type": struct {
				IsFromCsvSource                 bool
				RequiresGeneratedUndefinedValue bool
				Name                            string
				ValueSpecs                      []*ValueSpec
			}{
				IsFromCsvSource:                 ts.IsFromCsvSource,
				RequiresGeneratedUndefinedValue: requiresGeneratedUndefinedValue,
				Name:                            ts.Name,
				ValueSpecs:                      ts.ValueSpecs,
			},
		})
	}

	{ // standard functions
		tpl := template.Must(template.New("base-funcs").Funcs(tplFuncs).Parse(`
{{- /* Declare base functions of enum type */ -}}
{{- with $ts := .Type -}}
// {{ $ts.Name }}Values returns all values of the enum.
func {{ $ts.Name }}Values() []{{ $ts.Name }} {
	cp := _{{ $ts.Name }}Values
	return cp[:]
}

// {{ $ts.Name }}Strings returns a slice of all String values of the enum.
func {{ $ts.Name }}Strings() []string {
	cp := _{{ $ts.Name }}Strings
	return cp[:]
}

// IsValid inspects whether the value is valid enum value.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) IsValid() bool {
	return {{ receiver $ts.Name }} >= _{{ $ts.Name }}ValueRange[0] && {{ receiver $ts.Name }} <= _{{ $ts.Name }}ValueRange[1]
}

// Validate whether the value is within the range of enum values.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) Validate() error {
	if !{{ receiver $ts.Name }}.IsValid() {
		return fmt.Errorf("{{ $ts.Name }}(%d) is %w", {{ receiver $ts.Name }}, ErrNoValidEnum)
	}
	return nil
}

// String returns the string of the enum value.
// If the enum value is invalid, it will produce a string
// of the following pattern {{ $ts.Name }}(%d) instead.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) String() string {
	if !{{ receiver $ts.Name }}.IsValid() {
		return fmt.Sprintf("{{ $ts.Name }}(%d)", {{ receiver $ts.Name }})
	}
{{- if $ts.RequiresGeneratedUndefinedValue }}
{{- /* This block assures the proper serialization of the generated undefined Value */}}
	if {{ receiver $ts.Name }} == {{ $ts.Name }}Undefined {
		return ""
	}
{{- end }}
	idx := uint({{ receiver $ts.Name }}){{- if $ts.RequiresOffset }} - 1{{- end }}
	return _{{ $ts.Name }}Strings[idx]
}

{{ if $ts.HasAdditionalData }}
{{- /* Generate typed getter for additional data */}}
{{- range $col := $ts.DataColumns -}}
// Get{{ pascal $col.Name }} returns the "{{ $col.Name }}" of the enum value as {{ $col.Type }}
// if the enum is valid.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) Get{{ pascal $col.Name }}() ({{ $col.Type }}, bool) {
	if !{{ receiver $ts.Name }}.IsValid() {
		return {{ zero $col.Type }}, false
	}
	idx := uint({{ receiver $ts.Name }}){{- if $ts.RequiresOffset }} - 1{{- end }}
	d := _{{ $ts.Name }}AdditionalData[idx]
	return d.{{ pascal $col.Name }}, true
}

{{ end }}
{{- end }}
{{- end }}`))
		tpl.Execute(buf, map[string]any{
			"Type": struct {
				IsFromCsvSource                 bool
				RequiresGeneratedUndefinedValue bool
				RequiresOffset                  bool
				HasAdditionalData               bool
				Name                            string
				ValueSpecs                      []*ValueSpec
				DataColumns                     []AdditionalDataHeader
			}{
				IsFromCsvSource:                 ts.IsFromCsvSource,
				RequiresGeneratedUndefinedValue: requiresGeneratedUndefinedValue,
				RequiresOffset:                  ts.ValueSpecs[0].Value > 0,
				HasAdditionalData:               ts.HasAdditionalData,
				Name:                            ts.Name,
				ValueSpecs:                      ts.ValueSpecs,
				DataColumns: slices.Map(ts.DataColumns, func(v DataHeader, idx int) AdditionalDataHeader {
					return AdditionalDataHeader{v.Name, v.Type}
				}),
			},
		})
	}

	{ // value mappings and lookup
		tpl := template.Must(template.New("lookup-funcs").Funcs(tplFuncs).Parse(`
{{- /* Declare lookup functions of enum type */ -}}
{{- with $ts := .Type -}}
var (
	_{{ $ts.Name }}StringToValueMap = map[string]{{ $ts.Name }}{
{{- range $v := $ts.Values }}
		_{{ $ts.Name }}String[{{ $v.Position }}:{{ add $v.Position $v.Length }}]: {{ if $ts.IsFromCsvSource }}{{ $v.Value }}{{ else }}{{ $v.ConstName }}{{ end }},
{{- end }}
	}
	_{{ $ts.Name }}LowerStringToValueMap = map[string]{{ $ts.Name }}{
{{- range $v := $ts.Values }}
		_{{ $ts.Name }}LowerString[{{ $v.Position }}:{{ add $v.Position $v.Length }}]: {{ if $ts.IsFromCsvSource }}{{ $v.Value }}{{ else }}{{ $v.ConstName }}{{ end }},
{{- end }}
	}
)

// {{ $ts.Name }}FromString determines the enum value with an exact case match.
func {{ $ts.Name }}FromString(raw string) ({{ $ts.Name }}, bool) {
{{- if $ts.SupportUndefined }}
	if len(raw) == 0 {
		return {{ $ts.Name }}(0), true
	}
{{- end }}
	v, ok := _{{ $ts.Name }}StringToValueMap[raw]
	if !ok {
		return {{ $ts.Name }}(0), false
	}
	return v, true
}

// {{ $ts.Name }}FromStringIgnoreCase determines the enum value with a case-insensitive match.
func {{ $ts.Name }}FromStringIgnoreCase(raw string) ({{ $ts.Name }}, bool) {
{{- if $ts.SupportUndefined }}
	if len(raw) == 0 {
		return {{ $ts.Name }}(0), true
	}
{{- end }}
	v, ok := {{ $ts.Name }}FromString(raw)
	if ok {
		return v, ok
	}
	v, ok = _{{ $ts.Name }}LowerStringToValueMap[raw]
	if !ok {
		return {{ $ts.Name }}(0), false
	}
	return v, true
}

{{ end }}`))
		tpl.Execute(buf, map[string]any{
			"Type": struct {
				Name             string
				IsFromCsvSource  bool
				SupportUndefined bool
				Values           []EnumValue
			}{
				Name:             ts.Name,
				IsFromCsvSource:  ts.IsFromCsvSource,
				SupportUndefined: ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
				Values: slices.Map(ts.ValueSpecs, func(v *ValueSpec, idx int) EnumValue {
					var isAlternativeValue bool
					if idx > 0 {
						isAlternativeValue = v.Value == ts.ValueSpecs[idx-1].Value
					}
					return EnumValue{
						Value:     v.Value,
						String:    v.EnumValue,
						ConstName: v.IdentifierName,
						Position: slices.Reduce(ts.ValueSpecs[0:idx], func(v *ValueSpec, acc int) int {
							return acc + len(v.EnumValue)
						}),
						Length:             len(v.EnumValue),
						IsAlternativeValue: isAlternativeValue,
					}
				}),
			},
		})
	}

	{
		util.renderSerializers(buf, ts)
	}
	{
		if util.supportEntInterface {
			util.renderEntInterfaceSupport(buf, ts)
		}
	}
	return nil
}

type renderUtil struct {
	cfg                 *config.Options
	transform           stringCaseTransformer
	supportUndefined    bool
	supportEntInterface bool
}

type stringCaseTransformer func(v string) string

var (
	noopCaseTransformer = func(value string) string {
		return value
	}
	pascalCaseTransformer = func(value string) string {
		return strcase.ToPascal(value)
	}
	camelCaseTransformer = func(value string) string {
		return strcase.ToCamel(value)
	}
	kebabCaseTransformer = func(value string) string {
		return strcase.ToKebab(value)
	}
	snakeCaseTransformer = func(value string) string {
		return strcase.ToSnake(value)
	}
	lowerCaseTransformer = func(value string) string {
		return strings.ToLower(value)
	}
	upperCaseTransformer = func(value string) string {
		return strings.ToUpper(value)
	}
	upperSnakeCaseTransformer = func(value string) string {
		return strcase.ToSNAKE(value)
	}
	upperKebabCaseTransformer = func(value string) string {
		return strcase.ToKEBAB(value)
	}
	whitespaceCaseTransformer = func(value string) string {
		return strcase.ToCase(value, strcase.Original, ' ')
	}
)

func getTransformStrategy(c *config.Options) func(string) string {
	switch c.TransformStrategy {
	case "camel":
		return camelCaseTransformer
	case "pascal":
		return pascalCaseTransformer
	case "kebab":
		return kebabCaseTransformer
	case "snake":
		return snakeCaseTransformer
	case "lower":
		return lowerCaseTransformer
	case "upper":
		return upperCaseTransformer
	case "upper-kebab":
		return upperKebabCaseTransformer
	case "upper-snake":
		return upperSnakeCaseTransformer
	case "whitespace":
		return whitespaceCaseTransformer
	default:
		return noopCaseTransformer
	}
}

func (r *renderUtil) renderSerializers(buf *bytes.Buffer, ts *TypeSpec) {
	ignoreCase := r.cfg.SupportedFeatures.Contains(config.SupportIgnoreCase)
	for _, v := range r.cfg.Serializers {
		switch v {
		case "binary":
			r.renderBinarySerializers(buf, ts, ignoreCase)
		case "gql":
			r.renderGqlSerializers(buf, ts, ignoreCase)
		case "json":
			r.renderJsonSerializers(buf, ts, ignoreCase)
		case "text":
			r.renderTextSerializers(buf, ts, ignoreCase)
		case "sql":
			r.renderSqlSerializers(buf, ts, ignoreCase)
		case "yaml", "yaml.v3":
			isYamlV3 := v == "yaml.v3"
			r.renderYamlSerializers(buf, ts, ignoreCase, isYamlV3)
		}
	}
}

func (r *renderUtil) renderBinarySerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase bool) {
	tpl := template.Must(template.New("marshal-binary").Funcs(tplFuncs).Parse(`
{{- /* Declare binary interface for enum type */ -}}
{{- with $ts := .Type -}}
// MarshalBinary implements the encoding.BinaryMarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) MarshalBinary() ([]byte, error) {
	if err := {{ receiver $ts.Name }}.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as {{ $ts.Name }}. %w", {{ receiver $ts.Name }}, err)
	}
	return []byte({{ receiver $ts.Name }}.String()), nil
}

// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalBinary(text []byte) error {
	str := string(text)
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
		},
	})
}

func (r *renderUtil) renderGqlSerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase bool) {
	tpl := template.Must(template.New("marshal-graphql").Funcs(tplFuncs).Parse(`
{{- /* Declare graphql interface for enum type */ -}}
{{- with $ts := .Type -}}
// MarshalGQL implements the graphql.Marshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote({{ receiver $ts.Name }}.String()))
}

// UnmarshalGQL implements the graphql.Unmarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalGQL(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of {{ $ts.Name }}: %[1]T(%[1]v)", value)
	}
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
		},
	})
}

func (r *renderUtil) renderJsonSerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase bool) {
	tpl := template.Must(template.New("marshal-json").Funcs(tplFuncs).Parse(`
{{- /* Declare json interface for enum type */ -}}
{{- with $ts := .Type -}}
// MarshalJSON implements the json.Marshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) MarshalJSON() ([]byte, error) {
	if err := {{ receiver $ts.Name }}.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as {{ $ts.Name }}. %w", {{ receiver $ts.Name }}, err)
	}
	return json.Marshal({{ receiver $ts.Name }}.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalJSON(data []byte) error {
	var str string
	if err := json.Unmarshal(data, &str); err != nil {
		return fmt.Errorf("{{ $ts.Name }} should be a string, got %q", data)
	}
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
		},
	})
}

func (r *renderUtil) renderTextSerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase bool) {
	tpl := template.Must(template.New("marshal-text").Funcs(tplFuncs).Parse(`
{{- /* Declare text interface for enum type */ -}}
{{- with $ts := .Type -}}
// MarshalText implements the encoding.TextMarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) MarshalText() ([]byte, error) {
	if err := {{ receiver $ts.Name }}.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as {{ $ts.Name }}. %w", {{ receiver $ts.Name }}, err)
	}
	return []byte({{ receiver $ts.Name }}.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalText(text []byte) error {
	str := string(text)
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
		},
	})
}

func (r *renderUtil) renderSqlSerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase bool) {
	tpl := template.Must(template.New("marshal-sql").Funcs(tplFuncs).Parse(`
{{- /* Declare sql interface for enum type */ -}}
{{- with $ts := .Type -}}
// Value implements the sql/driver.Valuer interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) Value() (driver.Value, error) {
	if err := {{ receiver $ts.Name }}.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot serialize value %q as {{ $ts.Name }}. %w", {{ receiver $ts.Name }}, err)
	}
	return {{ receiver $ts.Name }}.String(), nil
}

// Scan implements the sql/driver.Scanner interface for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) Scan(value interface{}) error {
	var str string
	switch v := value.(type) {
	case nil:
	case []byte:
		str = string(v)
	case string:
		str = v
	case fmt.Stringer:
		str = v.String()
	default:
		return fmt.Errorf("invalid value of {{ $ts.Name }}: %[1]T(%[1]v)", value)
	}
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
		},
	})
}

func (r *renderUtil) renderYamlSerializers(buf *bytes.Buffer, ts *TypeSpec, ignoreCase, isV3 bool) {
	tpl := template.Must(template.New("marshal-yaml").Funcs(tplFuncs).Parse(`
{{- /* Declare yaml interface for enum type */ -}}
{{- with $ts := .Type -}}
// MarshalYAML implements a YAML Marshaler for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} {{ $ts.Name }}) MarshalYAML() (interface{}, error) {
	if err := {{ receiver $ts.Name }}.Validate(); err != nil {
		return nil, fmt.Errorf("Cannot marshal value %q as {{ $ts.Name }}. %w", {{ receiver $ts.Name }}, err)
	}
	return {{ receiver $ts.Name }}.String(), nil
}

{{ if $ts.SerializeYamlV3 -}}
// UnmarshalYAML implements a YAML Unmarshaler for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalYAML(n *yaml.Node) error {
	const stringTag = "!!str"
	if n.ShortTag() != stringTag {
		return fmt.Errorf("{{ $ts.Name }} must be derived from a string node")
	}
	str := n.Value
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}
{{- else -}}
// UnmarshalYAML implements a YAML Unmarshaler for {{ $ts.Name }}.
func ({{ receiver $ts.Name }} *{{ $ts.Name }}) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var str string
	if err := unmarshal(&str); err != nil {
		return err
	}
{{- if not $ts.SupportUndefined }}
	if len(str) == 0 {
		return fmt.Errorf("{{ $ts.Name }} cannot be derived from empty string")
	}
{{- end }}

	var ok bool
	*{{ receiver $ts.Name }}, ok = {{ $ts.Name }}FromString{{ if $ts.SupportIgnoreCase }}IgnoreCase{{ end }}(str)
	if !ok {
		return fmt.Errorf("Value %q does not represent a {{ $ts.Name }}", str)
	}
	return nil
}
{{- end }}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name              string
			SupportIgnoreCase bool
			SupportUndefined  bool
			SerializeYamlV3   bool
		}{
			Name:              ts.Name,
			SupportIgnoreCase: ts.Config.SupportedFeatures.Contains(config.SupportIgnoreCase),
			SupportUndefined:  ts.Config.SupportedFeatures.Contains(config.SupportUndefined),
			SerializeYamlV3:   isV3,
		},
	})
}

func (r *renderUtil) renderEntInterfaceSupport(buf *bytes.Buffer, ts *TypeSpec) {
	tpl := template.Must(template.New("marshal-sql").Funcs(tplFuncs).Parse(`
{{- /* Declare json interface for enum type */ -}}
{{- with $ts := .Type -}}
// Values returns a slice of all String values of the enum.
func ({{ $ts.Name }}) Values() []string {
	return {{ $ts.Name }}Strings()
}

{{ end }}`))
	tpl.Execute(buf, map[string]any{
		"Type": struct {
			Name string
		}{
			Name: ts.Name,
		},
	})
}
